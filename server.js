// server.js
// This file runs on your Node.js backend server.

require('dotenv').config();

const express = require('express');
const cors = require('cors');

const { GoogleGenerativeAI } = require('@google/generative-ai');

const app = express();
const PORT = process.env.PORT || 3001;

// âœ… Updated CORS configuration with YOUR specific Vercel URL
const corsOptions = {
    origin: 'https://ai-recipe-app-gules.vercel.app'
};
app.use(cors(corsOptions));

app.use(express.json());

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY);

const geminiModel = genAI.getGenerativeModel({
    model: "gemini-1.5-flash", // Updated to a newer, recommended model
    safetySettings: [
        { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
        { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
        { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
        { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
    ],
});

app.post('/generate-recipe', async (req, res) => {
    const { ingredientsText, preferenceText, servings, language } = req.body;

    if (!ingredientsText) {
        return res.status(400).json({ error: "Please add at least one ingredient." });
    }

    const recipePrompt = `
        You are an expert chef. Generate a detailed recipe in ${language} for ${servings} people using the following ingredients and their available quantities: ${ingredientsText}.
        Preferences: ${preferenceText}.

        Your task is to intelligently scale a recipe. Use the provided ingredients as the primary components. You can adjust the quantities in the final recipe to be appropriate for ${servings} people, but you must mention how much of the user's available ingredients are used.
        Assume common pantry staples like oil, salt, pepper, and basic spices are available.

        Provide a unique title, a short description, prep time, cook time, servings (which should match ${servings}), a list of ingredients with calculated quantities, and step-by-step instructions.

        IMPORTANT: Your response MUST be a single JSON object. Do NOT include any conversational text outside the JSON.
        The JSON object MUST contain two top-level keys: "recipe" (which is an object containing all recipe details) and "imageUrl" (which is a string containing the base64 encoded PNG image data, prefixed with "data:image/png;base64,").

        Generate a simple, appropriate image related to the recipe. If an image is not generated by the model, set "imageUrl" to an empty string.

        Example JSON structure:
        {
          "recipe": {
            "title": "Your Recipe Title",
            "description": "A brief description.",
            "prepTime": "15 mins",
            "cookTime": "30 mins",
            "servings": "${servings}",
            "ingredients": ["1 cup flour", "2 eggs"],
            "instructions": ["Step 1...", "Step 2..."]
          },
          "imageUrl": "data:image/png;base64,..."
        }
    `;

    try {
        const geminiResponse = await geminiModel.generateContent({
            contents: [{ role: "user", parts: [{ text: recipePrompt }] }],
            generationConfig: {
                responseMimeType: "application/json",
            },
        });

        const candidates = geminiResponse.response.candidates;
        let rawTextResponse = '';
        let extractedImageUrl = '';

        if (candidates && candidates.length > 0 && candidates[0].content && candidates[0].content.parts) {
            for (const part of candidates[0].content.parts) {
                if (part.text) {
                    rawTextResponse += part.text;
                } else if (part.inlineData && part.inlineData.mimeType.startsWith('image/')) {
                    extractedImageUrl = `data:${part.inlineData.mimeType};base64,${part.inlineData.data}`;
                }
            }
        }

        let finalRecipe = null;
        let finalImageUrl = '';

        try {
            const parsedFullResponse = JSON.parse(rawTextResponse);
            if (parsedFullResponse.recipe) {
                finalRecipe = parsedFullResponse.recipe;
                finalImageUrl = parsedFullResponse.imageUrl || extractedImageUrl;
            } else {
                finalRecipe = parsedFullResponse;
                finalImageUrl = extractedImageUrl;
            }
        } catch (parseError) {
            const jsonMatch = rawTextResponse.match(/```json\n([\s\S]*?)\n```/);
            if (jsonMatch && jsonMatch[1]) {
                try {
                    const parsedFromMarkdown = JSON.parse(jsonMatch[1]);
                    finalRecipe = parsedFromMarkdown.recipe || parsedFromMarkdown;
                    finalImageUrl = parsedFromMarkdown.imageUrl || extractedImageUrl;
                } catch (innerParseError) {
                    throw new Error("Gemini returned text that could not be parsed as valid JSON from markdown.");
                }
            } else {
                throw new Error("Gemini returned an unexpected response format. Expected JSON.");
            }
        }

        if (extractedImageUrl && !finalImageUrl) {
            finalImageUrl = extractedImageUrl;
        }

        if (!finalImageUrl) {
            finalImageUrl = '';
        }

        if (!finalRecipe) {
            throw new Error("Gemini did not return a valid recipe JSON. Please try again.");
        }

        res.json({ recipe: finalRecipe, imageUrl: finalImageUrl });

    } catch (error) {
        console.error('Backend Error during recipe/image generation:', error);
        let errorMessage = "Sorry, the kitchen is a bit busy! Couldn't generate a recipe. Please try again.";

        if (error.code === 8 || (error.details && error.details.includes("RESOURCE_EXHAUSTED"))) {
            errorMessage = "API quota exceeded. Please try again later.";
        } else if (error.code === 7 || (error.details && error.details.includes("PERMISSION_DENIED"))) {
            errorMessage = "Authentication error with Google API. Check your API key.";
        } else if (error.message.includes("could not be parsed as valid JSON")) {
            errorMessage = "AI model returned an unreadable response. Please try again.";
        }

        res.status(500).json({ error: errorMessage });
    }
});

app.listen(PORT, () => {
    console.log(`Backend server running on http://localhost:${PORT}`);
});